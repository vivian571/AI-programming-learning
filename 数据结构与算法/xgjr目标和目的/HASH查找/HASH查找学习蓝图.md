 # 哈希查找 (Hashing) 学习蓝图

## 学习目的 (Learning Purpose)

掌握哈希查找这一极其高效的数据查找技术，理解其如何实现“瞬间”定位数据。哈希是现代计算中无处不在的核心思想，从数据库索引到密码存储，再到编程语言中的字典和集合。学习哈希的目的是为了理解如何通过一个巧妙的“映射”函数，将复杂的查找问题转化为简单的数组索引问题，从而突破 O(n) 的线性查找瓶颈，实现 O(1) 的平均时间复杂度。这是通往高性能编程的关键一步。

## 学习目标 (Learning Objectives)

- **理论层面**:
  - **核心概念**: 理解哈希函数（Hash Function）、哈希表（Hash Table）和哈希冲突（Hash Collision）的定义和关系。
  - **哈希函数**: 了解一个好的哈希函数应具备的特性（如确定性、高效性、均匀分布性）。
  - **冲突解决**: 掌握两种最主流的哈希冲突解决方案：链地址法（Chaining）和开放地址法（Open Addressing），并能比较它们的优缺点。
  - **性能分析**: 能够解释为什么哈希表的平均时间复杂度是 O(1)，以及在什么情况下会退化到 O(n)。
- **实践层面**:
  - 能够利用 Python 的 `dict` 和 `set`，在算法题中高效解决查找、计数和去重问题。
  - 能够从零开始，使用 `list` of `list` 或 `list` of `LinkedList` 实现一个基于“链地址法”的简易哈希表。
  - 能够解决经典的“两数之和”问题，这是哈希表最典型的应用场景之一。
  - 能够应用哈希表实现一个简易的 LRU (最近最少使用) 缓存淘汰算法。

---

## 一、核心知识点 (Core Concepts)

### 1. 什么是哈希？
- **哈希函数 (Hash Function)**: 一个函数 `f`，它可以将任意大小的输入数据（称为 `key`）转换成一个固定大小的输出值，这个输出值称为**哈希值 (Hash Value)** 或**哈希码 (Hash Code)**。通常，哈希值是一个整数。
- **哈希表 (Hash Table)**: 一个基于哈希函数实现的数据结构。本质上它是一个**数组**，通过哈希函数计算出的哈希值来决定 `key` 应该存储在数组的哪个**索引（槽/桶，Slot/Bucket）**位置。
- **核心思想**: `index = hash(key) % array_size`。通过这个公式，我们可以将 `key` 和数组的索引建立起直接的映射关系。

### 2. 哈希冲突 (Hash Collision)
- **定义**: 当两个不同的 `key`（`key1 ≠ key2`）经过哈希函数计算后，得到了相同的哈希值（`hash(key1) == hash(key2)`），这种情况就叫做哈希冲突。
- **原因**: 输入空间（所有可能的`key`）通常远大于输出空间（数组的大小），所以冲突是**不可避免**的。
- **关键**: 如何设计高效的**冲突解决方案**是哈希表实现的核心。

### 3. 冲突解决方案
- **a) 链地址法 (Separate Chaining)**
  - **思路**: 哈希表的每个槽位（`slot`）不再只存一个元素，而是存放一个**链表**（或其他数据结构，如红黑树）。
  - **流程**:
    - 当插入一个新元素时，计算其哈希值找到对应的槽位。
    - 将该元素添加到这个槽位的链表中。
    - 当查找一个元素时，先找到对应的槽位，然后遍历该槽位的链表，找到目标元素。
  - **优点**: 实现简单，对哈希函数要求不高，可容忍较高的装载因子。
  - **Python实现**: Python 的 `dict` 和 `set` 早期版本主要使用此方法。
- **b) 开放地址法 (Open Addressing)**
  - **思路**: 所有元素都直接存放在哈希表（数组）中。当发生冲突时，按照某种规则去探测数组中的下一个可用的空槽位。
  - **常见探测方法**:
    1. **线性探测 (Linear Probing)**: `(hash(key) + i) % size`。发生冲突时，依次检查下一个、再下一个槽位，直到找到空位。
    2. **二次探测 (Quadratic Probing)**: `(hash(key) + i²) % size`。
    3. **双重哈希 (Double Hashing)**: 使用第二个哈希函数来计算步长。
  - **优点**: 数据更集中，缓存友好。
  - **缺点**: 实现更复杂，对装载因子更敏感，容易产生“聚集”现象（线性探测尤为明显）。
  - **Python实现**: Python 3.6+ 的 `dict` 结合了开放地址法和紧凑数组，实现了更优的性能和空间效率。

### 4. 装载因子 (Load Factor)
- **定义**: `α = 哈希表中元素的数量 / 哈希表数组的大小`。
- **意义**: 它衡量了哈希表的“满”的程度。`α` 越大，冲突的可能性越高。当 `α` 超过某个阈值（如0.75）时，通常需要进行**扩容 (rehashing)**，即创建一个更大的新数组，并将所有元素重新哈希到新数组中。

## 二、实践项目蓝图 (Practical Project Blueprint)

### 项目1: 实现一个基于链地址法的哈希集合 (HashSet)
- **目标**: 从零开始，实现一个只支持添加和查找功能的简易哈希集合。
- **步骤**:
  1.  创建一个 `MyHashSet` 类。
  2.  在 `__init__` 中，初始化一个固定大小的列表作为哈希表，例如 `self.table = [None] * 1000`。
  3.  实现一个简单的 `_hash(key)` 方法，返回 `key % 1000`。
  4.  实现 `add(key)` 方法：
      - 计算 `key` 的哈希值 `h`。
      - 如果 `self.table[h]` 是 `None`，就创建一个空链表（可以用`list`模拟）。
      - 将 `key` 添加到 `self.table[h]` 这个链表中（注意去重）。
  5.  实现 `contains(key)` 方法：
      - 计算 `key` 的哈希值 `h`。
      - 检查 `self.table[h]` 是否存在，并遍历其链表查找 `key`。
- **预期成果**: 一个可以工作的 `MyHashSet` 类，并通过测试验证其功能。

### 项目2: "两数之和" 问题 (LeetCode Easy)
- **目标**: 解决经典算法题：给定一个整数数组 `nums` 和一个目标值 `target`，请在该数组中找出和为目标值的那两个整数，并返回它们的索引。
- **暴力解法 (用于对比)**: 使用双重循环，检查每对数字的和。时间复杂度 `O(n²)`。
- **哈希表解法**:
  1.  创建一个哈希表（Python中用 `dict`），用于存储 {`数字`: `索引`}。
  2.  遍历数组 `nums`，对于每个数字 `num`：
      - 计算需要的“搭档”：`complement = target - num`。
      - **在哈希表中查找 `complement`**。如果找到了，说明配对成功，直接返回结果。
      - 如果没找到，将当前的 `num` 和它的索引存入哈希表：`hash_map[num] = i`。
  3.  这样，我们只需要遍历一次数组，每次查找都是 `O(1)`，总时间复杂度为 `O(n)`。
- **预期成果**: 一个高效的 `two_sum(nums, target)` 函数，深刻体会哈希表“用空间换时间”的强大威力。

### 项目3: 实现一个简易的LRU缓存
- **目标**: 实现一个 LRU (Least Recently Used) 缓存淘汰策略。LRU 缓存需要满足：
  1.  当访问一个数据时（`get` 操作），如果数据存在，则将其移动到“最近使用”的位置。
  2.  当添加一个新数据时（`put` 操作），如果缓存已满，则需要淘汰“最久未使用”的数据。
- **核心数据结构**:
  - **哈希表 (dict)**: 用于 `O(1)` 时间复杂度的快速查找。存储 `{key: Node}`。
  - **双向链表 (Doubly Linked List)**: 用于 `O(1)` 时间复杂度的节点移动（删除任意节点和添加到头部）。链表的顺序代表了从“最近使用”到“最久未使用”的顺序。
- **操作流程**:
  - **`get(key)`**:
    - 通过 `dict` 找到节点。
    - 将该节点从链表中移动到头部。
    - 返回节点的值。
  - **`put(key, value)`**:
    - 如果 `key` 已存在，更新值，并将节点移动到链表头部。
    - 如果 `key` 不存在：
      - 创建新节点，存入 `dict`，并添加到链表头部。
      - 如果缓存超容，删除链表尾部节点，并从 `dict` 中也删除对应的 `key`。
- **预期成果**: 一个 `LRUCache` 类，包含 `get` 和 `put` 方法，所有操作的平均时间复杂度均为 `O(1)`。
