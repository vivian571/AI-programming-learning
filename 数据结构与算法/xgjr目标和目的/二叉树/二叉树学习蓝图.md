 # 二叉树 (Binary Tree) 学习蓝图

## 学习目的 (Learning Purpose)

掌握二叉树，这是数据结构领域中至关重要的非线性结构。与线性结构（数组、链表）的一对一关系不同，树结构体现了清晰的**层级和分支**关系，是模拟现实世界中组织架构、文件系统等层级关系的天然模型。学习二叉树的目的是为了建立**“递归”和“分治”**的核心思维，因为几乎所有二叉树的操作都天然地可以用递归来优美地表达。它是通往更高级数据结构（如红黑树、B树）和复杂算法（如图论、动态规划）的必经之路。

## 学习目标 (Learning Objectives)

- **理论层面**:
  - **核心概念**: 理解节点、根、子树、叶子节点、深度、高度等基本术语。
  - **特殊形态**: 掌握满二叉树、完全二叉树和二叉搜索树（BST）的定义和特性。
  - **遍历**: 深刻理解并能手动模拟四种核心遍历方式：前序（Pre-order）、中序（In-order）、后序（Post-order）和层序（Level-order）。
  - **递归思想**: 能够将复杂的树问题（如求高度、判断对称）分解为对根节点的操作 + 对左右子树的递归调用。
- **实践层面**:
  - 能够从零开始，用 Python 类定义一个二叉树节点 `TreeNode`。
  - 能够熟练地使用**递归**和**迭代（使用栈或队列）**两种方法，实现前序、中序和后序遍历。
  - 能够使用队列实现层序遍历。
  - 能够解决一系列经典的二叉树问题，例如：
    - 求解二叉树的最大深度。
    - 判断一棵树是否是另一棵树的子树。
    - 翻转一棵二叉树。
    - 判断一棵二叉树是否是平衡的。

---

## 一、核心知识点 (Core Concepts)

### 1. 什么是二叉树？
- **定义**: 一种树形结构，其特点是每个节点**最多有两个子节点**，分别称为“左子节点 (left child)”和“右子节点 (right child)”。
- **基本组成**:
  - **节点 (Node)**: 包含一个数据元素及指向其左、右子节点的指针。
  - **根节点 (Root)**: 树的顶层节点。
  - **叶子节点 (Leaf)**: 没有子节点的节点。

### 2. 二叉树的种类
- **满二叉树 (Full Binary Tree)**: 一个深度为 `k` 且有 `2^k - 1` 个节点的二叉树。每一层的节点数都达到了最大值。
- **完全二叉树 (Complete Binary Tree)**: 对一棵深度为 `k` 的树，从第 `1` 层到 `k-1` 层都是满的，且第 `k` 层的节点都**连续地集中在左边**。完全二叉树非常重要，因为它可以方便地用数组来表示（堆就是基于此）。
- **二叉搜索树 (Binary Search Tree, BST)**: 一种特殊的二叉树，对于树中任意节点，满足：
  - 其左子树中所有节点的值都**小于**该节点的值。
  - 其右子树中所有节点的值都**大于**该节点的值。
  - 其左、右子树也分别为二叉搜索树。
  - **特性**: 对BST进行**中序遍历**，可以得到一个有序的序列。

### 3. 二叉树的遍历
遍历是指按照某种顺序访问树中的每一个节点，且每个节点只被访问一次。
- **深度优先搜索 (DFS)**
  - **前序遍历 (Pre-order)**: **根 -> 左 -> 右**。常用于树的复制、展示树的结构。
  - **中序遍历 (In-order)**: **左 -> 根 -> 右**。在二叉搜索树中，得到的是有序序列。
  - **后序遍历 (Post-order)**: **左 -> 右 -> 根**。常用于计算、释放树的资源（先处理子节点，再处理父节点）。
- **广度优先搜索 (BFS)**
  - **层序遍历 (Level-order)**: 从上到下，从左到右，逐层访问。通常使用**队列 (Queue)** 来实现。

## 二、实践项目蓝图 (Practical Project Blueprint)

### 项目1: 二叉树遍历的实现
- **目标**: 掌握递归和迭代两种方法实现三种DFS遍历，以及用队列实现BFS遍历。
- **步骤**:
  1.  定义一个 `TreeNode` 类，包含 `val`, `left`, `right` 属性。
  2.  **递归实现**:
      - `preorder_recursive(root)`
      - `inorder_recursive(root)`
      - `postorder_recursive(root)`
      - 递归实现非常直观，代码简洁，能深刻体现DFS的思想。
  3.  **迭代实现 (使用栈)**:
      - `preorder_iterative(root)`: 先`push`根，然后循环中`pop`节点，先`push`右子节点，再`push`左子节点。
      - `inorder_iterative(root)`: 一路向左，将所有左侧链上的节点`push`入栈；`pop`一个节点并访问，然后转向其右子树。
      - `postorder_iterative(root)`: 略复杂，一种技巧是模拟前序遍历（根右左），然后将结果反转。
  4.  **层序遍历 (使用队列)**:
      - `levelorder(root)`: 将根节点入队。循环中，出队一个节点并访问，然后将其非空的左、右子节点依次入队。
- **预期成果**:
  - 四种遍历方式、共七个实现函数。
  - 通过构建一个具体的二叉树实例，验证所有遍历函数输出的结果都是正确的。

### 项目2: 经典的二叉树递归问题
- **目标**: 通过解决一系列经典问题，熟练运用递归思想处理二叉树。
- **问题列表**:
  1.  **最大深度 (LeetCode 104)**: `maxDepth(root)`
      - **思路**: `1 + max(maxDepth(root.left), maxDepth(root.right))`
  2.  **翻转二叉树 (LeetCode 226)**: `invertTree(root)`
      - **思路**: 交换左右子节点，然后递归地翻转左右子树。`root.left, root.right = invertTree(root.right), invertTree(root.left)`。
  3.  **判断对称二叉树 (LeetCode 101)**: `isSymmetric(root)`
      - **思路**: 需要一个辅助函数 `isMirror(t1, t2)`，判断两棵树是否镜像对称。递归的条件是 `t1.val == t2.val` 且 `isMirror(t1.left, t2.right)` 且 `isMirror(t1.right, t2.left)`。
  4.  **路径总和 (LeetCode 112)**: `hasPathSum(root, sum)`
      - **思路**: 递归地将 `sum` 减去当前节点值，并传递给子树。当到达叶子节点时，检查 `sum` 是否等于该叶子节点的值。
- **预期成果**:
  - 针对以上每个问题，编写出简洁、正确的递归解法。
  - 通过这些练习，形成解决二叉树问题的固定思维模式：**先考虑当前根节点需要做什么，然后假设递归函数能正确处理左右子树，最后将结果组合起来。**
