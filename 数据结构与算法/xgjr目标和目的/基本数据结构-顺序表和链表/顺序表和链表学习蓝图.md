 # 顺序表与链表学习蓝图

## 学习目的 (Learning Purpose)

掌握并深刻理解两种最基础、最核心的线性数据结构：顺序表（数组）和链表。这两种结构是构建几乎所有其他复杂数据结构（如栈、队列、哈希表、树）的基石。学习它们的目的是为了理解数据在内存中两种最根本的组织方式——“连续存储”与“离散存储”，并能根据不同操作（如查找、插入、删除）的性能需求，做出最合适的技术选型。这是数据结构与算法入门的第一道大门。

## 学习目标 (Learning Objectives)

- **理论层面**:
  - **顺序表**:
    - 理解其“连续内存空间”的核心特性。
    - 掌握其随机访问 O(1) 的巨大优势。
    - 理解其插入和删除操作 O(n) 的性能瓶颈及其原因。
  - **链表**:
    - 理解其“指针链接、离散存储”的核心特性。
    - 掌握单向链表、双向链表和循环链表的结构与区别。
    - 理解其插入和删除操作 O(1) 的优势（在给定节点的情况下）。
    - 认识到其查找操作 O(n) 的劣势。
- **实践层面**:
  - 能够从零开始，用 Python 类实现一个功能完整的单向链表（包括节点的创建、增、删、改、查）。
  - 能够实现链表的反转，这是链表操作最经典的面试题之一。
  - 能够解决“判断链表是否有环”的问题，并理解快慢指针（追及问题）的应用。
  - 能够在一个实际场景中（如简单的播放列表），分析并选择使用顺序表还是链表，并解释原因。

---

## 一、核心知识点 (Core Concepts)

### 1. 顺序表 (Sequential List / Array)
- **定义**: 在内存中开辟一段**连续的存储空间**来存放数据元素。
- **Python中的体现**: `list` 和 `tuple` 的底层实现就是顺序表（动态数组和静态数组）。
- **优点**:
  - **随机访问效率高**: `O(1)`。由于内存连续，可以通过 `基地址 + 索引 * 元素大小` 的公式直接计算出任何一个元素的内存地址，实现快速访问。
- **缺点**:
  - **插入和删除效率低**: `O(n)`。在任意位置插入或删除一个元素，需要移动该位置之后的所有元素来维持连续性。
  - **空间限制**: 创建时可能需要预估大小，如果空间不足需要进行昂贵的扩容操作（重新分配更大的连续空间并拷贝数据）。

### 2. 链表 (Linked List)
- **定义**: 由一系列**节点 (Node)** 组成，每个节点包含两部分：**数据域 (Data)** 和指向下一个节点的**指针域 (Next)**。它们在内存中是**离散存储**的。
- **优点**:
  - **插入和删除效率高**: `O(1)`。只需要修改目标位置前后节点的指针即可，无需移动大量数据。
  - **空间利用率高**: 按需分配内存，没有空间浪费问题。
- **缺点**:
  - **查找效率低**: `O(n)`。无法随机访问，必须从头节点开始，沿着指针逐个遍历才能找到目标元素。
  - **需要额外空间**: 每个节点都需要额外的空间来存储指针。

### 3. 链表的分类
- **单向链表 (Singly Linked List)**: 每个节点只有一个指向后继节点的指针。
- **双向链表 (Doubly Linked List)**: 每个节点有两个指针，一个指向前驱节点 (`prev`)，一个指向后继节点 (`next`)。这使得双向遍历成为可能，但代价是需要更多的指针存储空间。
- **循环链表 (Circular Linked List)**: 尾节点的指针不是指向 `None`，而是指向头节点，形成一个环。

### 4. 总结对比
| 特性 | 顺序表 (数组) | 链表 |
| :--- | :--- | :--- |
| **存储方式** | 连续内存 | 离散内存，指针链接 |
| **随机访问** | `O(1)` | `O(n)` |
| **按值查找** | `O(n)` | `O(n)` |
| **插入/删除**| `O(n)` (涉及元素移动) | `O(1)` (给定节点时) |
| **空间占用** | 紧凑，但可能预分配浪费 | 有额外的指针开销 |

## 二、实践项目蓝图 (Practical Project Blueprint)

### 项目1: 从零实现一个单向链表
- **目标**: 不使用任何内置库，纯手写一个功能完善的单向链表类。
- **步骤**:
  1.  **创建 `Node` 类**: 包含 `data` 和 `next` 两个属性。
  2.  **创建 `LinkedList` 类**:
      - 包含一个 `head` 属性，指向链表的头节点。
      - 实现 `is_empty()` 方法。
      - 实现 `append(data)` 方法：在链表尾部添加新节点。
      - 实现 `prepend(data)` 方法：在链表头部添加新节点。
      - 实现 `insert(index, data)` 方法：在指定位置插入新节点。
      - 实现 `remove(data)` 方法：删除第一个匹配的节点。
      - 实现 `search(data)` 方法：查找数据是否存在。
      - 实现 `__len__()` 和 `__str__()` 方法，以便于使用 `len()` 和 `print()`。
- **预期成果**: 一个健壮的、可复用的 `LinkedList` 类，并通过一系列单元测试来验证其正确性。

### 项目2: 链表反转
- **目标**: 实现一个函数，接收一个链表的头节点，将整个链表反转，并返回新的头节点。
- **迭代法思路 (推荐)**:
  1.  需要三个指针：`prev` (指向前一个节点，初始为 `None`)，`curr` (指向当前节点，初始为 `head`)，`next_node` (用于临时保存下一个节点)。
  2.  遍历链表，对于每个 `curr` 节点：
      - 保存下一个节点: `next_node = curr.next`。
      - **反转指针**: `curr.next = prev`。
      - 移动指针: `prev = curr`, `curr = next_node`。
  3.  循环结束后，`prev` 将指向新的头节点。
- **递归法思路 (进阶)**:
  - 基线条件：如果链表为空或只有一个节点，直接返回 `head`。
  - 递归调用 `reverse(head.next)` 来反转剩余部分，得到新头节点 `new_head`。
  - 将 `head` 节点的指针反转：`head.next.next = head` 和 `head.next = None`。
  - 返回 `new_head`。
- **预期成果**: 两种方法的 `reverse_linked_list(head)` 函数，并通过测试验证其功能。

### 项目3: 判断链表是否有环 (快慢指针法)
- **目标**: 实现一个函数，判断一个给定的链表是否包含环。
- **算法思路 (Floyd's Tortoise and Hare Algorithm)**:
  1.  创建两个指针：`slow` (慢指针，一次走一步) 和 `fast` (快指针，一次走两步)，都从 `head` 开始。
  2.  在一个循环中移动它们：
      - 如果 `fast` 指针或 `fast.next` 指针到达了 `None`，说明链表没有环，遍历结束。
      - 如果在某一时刻，`fast` 指针与 `slow` 指针相遇 (`fast == slow`)，说明链表中有环。
- **为什么能相遇?**: 就像在环形跑道上跑步，速度快的人最终一定会追上（套圈）速度慢的人。
- **预期成果**:
  - 一个 `has_cycle(head)` 函数，返回 `True` 或 `False`。
  - (进阶) 如果有环，找到环的入口节点。 (提示: 相遇后，将一个指针放回头节点，然后两个指针都以一次一步的速度前进，再次相遇点即为入口)。
