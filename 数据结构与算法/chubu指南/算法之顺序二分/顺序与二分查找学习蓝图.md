 
# 顺序查找与二分查找学习蓝图

## 一、核心知识点 (Core Concepts)

查找（Search）是算法中最基本的需求之一。顺序查找和二分查找是两种最基础的查找算法，代表了线性和对数时间复杂度的典型思想。

---

### 1. 顺序查找 (Sequential Search)
- **别名**: 线性查找 (Linear Search)。
- **定义**: 从数据结构的一端开始，逐个检查元素，直到找到目标元素或检查完所有元素为止。
- **适用性**:
  - 适用于任何线性数据结构，如列表、链表等。
  - **对数据是否有序没有要求**。
- **算法步骤**:
  1. 从第一个元素开始 (`index = 0`)。
  2. 比较当前元素与目标值。
  3. 如果相等，返回当前索引。
  4. 如果不相等，移动到下一个元素 (`index++`)。
  5. 如果遍历完所有元素仍未找到，返回一个特殊值（如 `-1` 或 `False`）。
- **复杂度分析**:
  - **时间复杂度**:
    - **最坏情况**: `O(n)` (目标元素在末尾或不存在)。
    - **最好情况**: `O(1)` (目标元素在开头)。
    - **平均情况**: `O(n)`。
  - **空间复杂度**: `O(1)` (只需要少量额外变量)。

---

### 2. 二分查找 (Binary Search)
- **别名**: 折半查找。
- **核心前提**: **必须在有序的数据集上执行** (例如，一个已排序的数组)。
- **定义**: 通过不断将搜索范围缩小一半来快速定位目标元素的算法。
- **算法步骤 (迭代版)**:
  1. 初始化三个指针：`low = 0`, `high = n-1` (n为数组长度)。
  2. 当 `low <= high` 时，循环执行：
     a. 计算中间位置 `mid = low + (high - low) // 2` (这样写可以防止 `low+high` 溢出)。
     b. 获取中间值 `guess = array[mid]`。
     c. **比较**:
        - 如果 `guess == target`，查找成功，返回 `mid`。
        - 如果 `guess < target`，说明目标值在右半部分，更新 `low = mid + 1`。
        - 如果 `guess > target`，说明目标值在左半部分，更新 `high = mid - 1`。
  3. 如果循环结束仍未找到，返回 `-1`。
- **复杂度分析**:
  - **时间复杂度**: **`O(log n)`**。每次循环都将搜索空间减半，所以查找次数约为 `log₂n`。这是二分查找最大的优势。
  - **空间复杂度**:
    - **迭代版**: `O(1)`。
    - **递归版**: `O(log n)`，因为需要函数调用栈空间。

## 二、实践项目蓝图 (Practical Project Blueprint)

### 项目1: 猜数字游戏
- **目标**: 实现一个经典的猜数字游戏，并观察人类玩家与计算机玩家在使用不同策略时的效率差异。
- **游戏规则**:
  1. 程序随机生成一个 1 到 100 之间的整数。
  2. **人类玩家回合**: 玩家输入猜测的数字，程序给出“太高了”、“太低了”或“猜对了”的提示。记录玩家猜测的次数。
  3. **计算机玩家回合**:
     - **策略A (顺序查找)**: 计算机从 1 开始，依次猜测 2, 3, ... 直到猜对。
     - **策略B (二分查找)**: 计算机将搜索范围初始化为 `[1, 100]`。每次猜测中间值，根据“太高/太低”的反馈来缩小下一次的搜索范围。
  4. 对比人类玩家、策略A、策略B在找到同一个数字时所用的猜测次数。
- **预期成果**:
  - 一个可玩的猜数字游戏。
  - 清晰地展示出二分查找策略的 guesses 次数远少于顺序查找，通常也少于人类的直觉猜测。
  - 一份笔记，总结为什么二分查找如此高效。

### 项目2: 实现健壮的二分查找函数
- **目标**: 编写一个功能完整且能处理各种边界情况的二分查找函数。
- **功能要求**:
  1.  实现一个基本的二分查找函数 `binary_search(sorted_array, target)`，返回目标值的索引，如果不存在则返回 -1。
  2.  **变体1: 查找第一个等于 target 的元素**。
      - 当 `array[mid] == target` 时，不要立即返回，而是记录下这个 `mid`，然后尝试在左半部分继续查找 (`high = mid - 1`)，看是否能找到更靠前的。
  3.  **变体2: 查找最后一个等于 target 的元素**。
      - 类似地，当 `array[mid] == target` 时，记录 `mid`，然后在右半部分继续查找 (`low = mid + 1`)。
  4.  **变体3: 查找第一个大于等于 target 的元素**。
  5.  **变体4: 查找最后一个小于等于 target 的元素**。
- **预期成果**:
  - 一个包含上述所有查找功能的Python文件。
  - 为每个函数编写单元测试，覆盖数组为空、target存在/不存在、target在边界等多种情况。
  - 通过实现这些变体，深刻理解二分查找的精髓和灵活性。

### 项目3: 在“答案空间”上进行二分查找
- **目标**: 解决一个不是直接在数组上查找，而是在一个可能的“答案范围”内使用二分查找的问题。
- **经典问题**: (LeetCode 875. 爱吃香蕉的珂珂)
  - **问题描述**: 珂珂喜欢吃香蕉。这里有 `N` 堆香蕉，第 `i` 堆中有 `piles[i]` 根香蕉。警卫将在 `H` 小时后回来。珂珂可以决定她吃香蕉的速度 `K` (根/小时)。每个小时，她会选择一堆香蕉，从中吃掉 `K` 根。如果这堆香蕉不到 `K` 根，她会吃完这堆的所有香蕉，然后这个小时内不会再吃更多了。珂珂想在警卫回来前吃完所有香蕉，但又想吃得尽量慢。求她可以成功吃完所有香蕉的**最小速度 `K`**。
- **算法思路**:
  1. **确定答案的范围**: 速度 `K` 的最小值是 1，最大值可以是香蕉堆中最多的那堆 `max(piles)`。我们就在 `[1, max(piles)]` 这个**答案空间**上进行二分查找。
  2. **`check(speed)` 函数**: 对于一个给定的速度 `speed`，我们能判断出珂珂能否在 `H` 小时内吃完所有香蕉吗？这是可以的。遍历 `piles`，计算吃完每堆香蕉所需的时间 `ceil(pile / speed)`，求和得到总时间 `total_time`。如果 `total_time <= H`，说明这个速度是可行的。
  3. **二分查找**:
     - `low = 1`, `high = max(piles)`。
     - 每次取 `mid_speed`，调用 `check(mid_speed)`。
     - 如果可行，说明 `mid_speed` 可能就是答案，或者还可以更慢。我们尝试更小的速度，所以 `high = mid_speed - 1`，并记录下这个可行的 `mid_speed`。
     - 如果不可行，说明速度太慢了，必须加快，所以 `low = mid_speed + 1`。
- **预期成果**:
  - 一个解决该问题的Python函数。
  - 理解二分查找不仅可以用于具体数组，更可以用于任何具有**单调性**的搜索空间。如果一个答案 `x` 可行，那么所有 `>x` 的答案都可行，这就构成了可以使用二分查找的单调性。
