# 队列 (Queue) 学习蓝图

## 一、核心知识点 (Core Concepts)

### 1. 什么是队列？
- **定义**: 队列是另一种受限的线性表，它只允许在一端进行插入操作，而在另一端进行删除操作。进行插入操作的一端称为**队尾 (rear)**，进行删除操作的一端称为**队头 (front)**。
- **核心特性**: **FIFO (First-In, First-Out)**，即"先进先出"。最早进入队列的元素最先被移出。
- **类比**: 就像在食堂排队打饭，先来的人先打饭，后来的人排在队尾。

### 2. 队列的基本操作
- **`enqueue(item)`**: 入队。将一个元素添加到队尾。
- **`dequeue()`**: 出队。从队头移除一个元素，并返回该元素。
- **`peek()`** 或 **`front()`**: 查看队头元素，但不移除它。
- **`is_empty()`**: 检查队列是否为空。
- **`size()`**: 获取队列中元素的个数。

### 3. 队列的实现方式
- **基于列表 (List) 实现**:
  - **缺点**: 非常低效！如果用 `list.append()` 作为入队 (队尾)，那么出队 (队头) 就必须用 `list.pop(0)`，这是一个 `O(n)` 操作，因为需要移动所有后续元素。反之亦然。因此，**强烈不推荐**用普通列表实现队列。
- **基于 `collections.deque` 实现 (Python标准库)**:
  - **优点**: `deque` (Double-ended queue, 双端队列) 是专门为快速在两端添加和删除元素而设计的。它的 `append()` (队尾入队) 和 `popleft()` (队头出队) 操作都是 `O(1)` 的。
  - **最佳实践**: 在Python中，`collections.deque` 是实现标准队列的**首选方式**。
- **基于链表 (Linked List) 实现**:
  - **优点**: 可以更好地理解队列的内部工作原理。通过维护指向链表头部和尾部的两个指针，可以实现 `O(1)` 的入队和出队操作。
  - **实现**:
    - `enqueue`: 在链表尾部添加新节点。
    - `dequeue`: 在链表头部删除节点。

## 二、实践项目蓝图 (Practical Project Blueprint)

### 项目1: 模拟打印机任务队列
- **目标**: 编写一个程序，模拟多台打印机处理打印任务的场景。
- **算法思路**:
  1. 创建一个队列 `task_queue` 来存放待打印的文件（可以是简单的字符串，如 "Document1.pdf"）。
  2. 模拟一个时间循环。在每个时间单位里：
     a. **新任务到达**: 以一定的概率随机生成新的打印任务，并将其 `enqueue` 到 `task_queue` 中。
     b. **打印机处理**: 检查是否有空闲的打印机。如果有，并且 `task_queue` 不为空，那么从队列中 `dequeue` 一个任务，并将其分配给打印机。打印机开始处理任务（可以设定每个任务需要一个固定的时间来完成）。
     c. **打印完成**: 检查是否有打印机完成了它的任务，如果完成了，则将其设置为空闲状态。
  3. 记录每个任务从进入队列到打印完成所花费的等待时间。
- **预期成果**:
  - 一个Python脚本，能够模拟打印队列的工作流程。
  - 程序可以输出日志，显示任务的到达、被处理和完成。
  - (进阶) 计算并输出所有任务的平均等待时间，尝试调整打印机数量或任务到达频率，观察对平均等待时间的影响。

### 项目2: "烫手山芋"游戏模拟器
- **目标**: 模拟一个经典的游戏，一群孩子围成一圈，传递一个"烫手山芋"，计时器响起时，拿着山芋的孩子出局。
- **算法思路**:
  1. 将所有参与者的名字 `enqueue` 到一个队列中。
  2. 设定一个随机的传递次数 `N`。
  3. 进行循环，每次循环代表一次传递：
     - 从队头 `dequeue` 一个孩子。
     - 立即将这个孩子 `enqueue` 到队尾。
     - 这模拟了山芋被传递给了队里的下一个人。
  4. 重复步骤3 `N-1` 次。
  5. 第 `N` 次 `dequeue` 的孩子就是这一轮的出局者。
  6. 重复整个过程，直到队列中只剩下最后一个孩子，他就是胜利者。
- **预期成果**:
  - 一个Python函数 `hot_potato(name_list, num)`，接受参与者列表和每轮传递次数，返回胜利者的名字。
  - 程序能清晰地展示每一轮谁被淘汰了。

### 项目3: 广度优先搜索 (BFS) 算法基础
- **目标**: 使用队列来实现一个简单的广度优先搜索，找到从一个节点到另一个节点的最短路径（在无权图中）。
- **场景**: 假设你有一个简单的社交网络图（可以用字典表示，`{'A': ['B', 'C'], 'B': ['D']...}`），你想找到两个人之间的最短联系路径。
- **算法思路**:
  1. 创建一个队列，并将起始节点（例如 'A'）入队。
  2. 创建一个集合 `visited` 来记录已访问过的节点，避免死循环。
  3. 当队列不为空时，循环执行：
     a. 从队头 `dequeue` 一个节点 `current_node`。
     b. 如果 `current_node` 是目标节点，搜索结束。
     c. 遍历 `current_node` 的所有邻居节点：
        - 如果邻居节点没有在 `visited` 中，就将其标记为已访问，并 `enqueue` 到队列中。
  4. (进阶) 为了找到路径，队列中可以存储路径列表，而不仅仅是节点。例如，入队 `['A', 'B']` 而不是 `'B'`。
- **预期成果**:
  - 理解队列是BFS算法的核心。
  - 一个能够在一个简单的图中执行BFS的Python函数。 