# HASH查找 (哈希查找) 学习蓝图

## 一、核心知识点 (Core Concepts)

### 1. 什么是哈希查找？
- **定义**: 哈希查找是一种通过**哈希函数 (Hash Function)** 将要查找的键 (Key) 映射到一个索引 (Index)，然后直接访问该索引位置来获取值 (Value) 的查找方法。这种键与值配对存储、并通过键来查找值的数据结构称为**哈希表 (Hash Table)** 或**散列表**。
- **核心思想**: 以空间换时间。通过预计算的索引，将查找时间复杂度从线性/对数级别降至常数级别。
- **类比**: 就像一本字典，你知道单词 (Key)，可以直接通过首字母索引 (哈希函数) 快速翻到那一页 (索引)，而不需要从头到尾一页一页地找。

### 2. 哈希表的构成要素
- **哈希函数 `hash(key)`**:
  - **作用**: 负责将任意长度的输入 (Key) 转换为固定长度的输出 (哈希值/索引)。
  - **要求**:
    1. **确定性**: 同一个 `key` 多次调用哈希函数，必须返回相同的结果。
    2. **高效性**: 计算速度要快。
    3. **均匀性**: `key` 经过哈希后，应尽可能均匀地分布在哈希表的各个位置，以减少冲突。
- **哈希表本体 (Table/Bucket Array)**:
  - 通常是一个数组或列表，用于存储数据。数组的每个位置称为一个**桶 (Bucket)** 或**槽 (Slot)**。
- **冲突解决 (Collision Resolution)**:
  - **定义**: 两个不同的 `key` 经过哈希函数计算后得到了相同的索引，这种情况称为**哈希冲突**。
  - **这是哈希表实现中最关键、最复杂的部分**。没有完美的哈希函数能完全避免冲突，所以必须有解决冲突的机制。

### 3. 常见的冲突解决方法
- **拉链法 (Chaining)** / **链地址法**:
  - **思路**: 哈希表的每个桶不直接存储数据，而是存储一个**链表**（或其他数据结构，如红黑树）的头节点。所有哈希到同一个桶的键值对，都将被添加到这个链表中。
  - **查找过程**: 先通过哈希函数找到对应的桶，然后遍历该桶的链表，找到正确的键。
  - **优点**: 实现简单，对哈希函数均匀性要求相对较低，能容忍较高的装载因子。
  - **Python的 `dict` 和 `set` 主要就是采用这种方法**。
- **开放地址法 (Open Addressing)**:
  - **思路**: 当发生冲突时，不创建链表，而是按照某种规则在哈希表中继续寻找下一个可用的空桶来存放元素。
  - **查找过程**: 先通过哈希函数找到原始桶，如果不是目标元素，则按同样的规则探测下一个桶，直到找到目标或遇到空桶。
  - **常见探测方法**:
    - **线性探测 (Linear Probing)**: `(hash(key) + i) % n`，按顺序向后找。易产生"聚集"现象。
    - **二次探测 (Quadratic Probing)**: `(hash(key) + i²) % n`，按二次方步长跳跃。
    - **双重哈希 (Double Hashing)**: 使用第二个哈希函数来决定步长。

### 4. 性能分析
- **时间复杂度**:
  - **平均情况 (无冲突或冲突少)**: **`O(1)`** 用于插入、删除、查找。这是哈希表的巨大优势。
  - **最坏情况**: **`O(n)`**。当所有键都冲突到同一个桶时，哈希表退化成一个链表，查找需要遍历所有元素。
- **空间复杂度**: `O(n)`，需要存储所有n个键值对。
- **装载因子 (Load Factor)**:
  - `α = 存储的元素数量 / 哈希表的大小`
  - 这个值衡量了哈希表的"满"的程度。`α` 越大，冲突的可能性越高，性能越接近 `O(n)`。当 `α` 超过某个阈值（如0.75）时，通常需要对哈希表进行**扩容 (rehash)**。

## 二、实践项目蓝图 (Practical Project Blueprint)

### 项目1: 实现一个基于拉链法的哈希表
- **目标**: 从零开始，手动实现一个功能完整的、使用拉链法解决冲突的哈希表。
- **功能要求**:
  1.  **`HashTable` 类**:
      - `__init__(size)`: 初始化，创建一个指定大小的、由空列表组成的列表（桶数组）。
      - `_hash(key)`: 一个私有的哈希方法，将键转换为桶的索引。可以简单地用 `hash(key) % self.size` 实现。
      - `put(key, value)`:
        - 计算 `key` 的哈希值找到桶。
        - 遍历桶内的链表（可以用元组 `(key, value)` 列表模拟）。
        - 如果 `key` 已存在，更新 `value`。
        - 如果 `key` 不存在，将新的 `(key, value)` 对追加到链表中。
      - `get(key)`:
        - 计算哈希值找到桶。
        - 遍历链表，找到对应的 `key` 并返回 `value`。如果找不到，返回 `None`。
      - `remove(key)`:
        - 计算哈希值找到桶。
        - 遍历链表，找到并删除对应的 `(key, value)` 对。
  2. (进阶) 实现**动态扩容**: 当装载因子超过阈值时，创建一个更大的新桶数组，并将所有旧元素重新哈希（rehash）到新数组中。
- **预期成果**:
  - 一个功能类似于Python字典的 `HashTable` 类。
  - 编写测试用例来验证 `put`, `get`, `remove` 和扩容功能的正确性。

### 项目2: "两数之和" 问题的高效解法
- **目标**: 解决经典的 "Two Sum" 算法题，并体会哈希查找带来的性能提升。
- **问题描述**: 给定一个整数数组 `nums` 和一个目标值 `target`，请在该数组中找出和为 `target` 的那两个整数，并返回它们的数组下标。
- **算法思路**:
  1. **暴力解法 `O(n²)`**: 使用双重循环，遍历所有可能的数字对，检查它们的和是否等于 `target`。
  2. **哈希查找解法 `O(n)`**:
     - 创建一个空的哈希表 `value_to_index_map`。
     - 只需遍历数组**一次**：
       - 对于每个数字 `num`，计算它需要的"配对数" `complement = target - num`。
       - 在哈希表中**查找** `complement` 是否存在。
         - 如果存在，说明找到了配对，立即返回 `complement` 的索引和当前 `num` 的索引。
         - 如果不存在，将当前的 `num` 及其索引存入哈希表 `value_to_index_map[num] = index`，供后续的数字进行配对。
- **预期成果**:
  - 实现暴力解法和哈希查找解法两个函数。
  - 使用 `timeit` 或在一个非常大的数组上进行测试，直观地对比 `O(n²)` 和 `O(n)` 的巨大性能差距。
  - 深刻理解哈希表如何将查找过程从 `O(n)` 优化到 `O(1)`，从而降低整体算法的时间复杂度。

### 项目3: 文件内容去重工具
- **目标**: 编写一个脚本，可以快速识别并删除一个目录下的重复文件。
- **算法思路**:
  1. 使用哈希查找来存储文件的"指纹"和路径。
  2. **选择哈希函数**: 使用 `hashlib` 模块中的 `md5` 或 `sha256` 算法。这些加密哈希函数能为文件内容生成一个几乎唯一的、固定长度的字符串作为"指纹"。
  3. **遍历文件**:
     - 创建一个字典 `fingerprint_to_path = {}`。
     - 遍历指定目录下的所有文件。
     - 对每个文件，读取其**二进制内容**，并计算其哈希值（指纹）。
     - **检查冲突**:
       - 如果该指纹已存在于字典中，说明这是一个重复文件。记录下当前文件路径和字典中已有的路径。
       - 如果指纹不存在，将 `{指纹: 文件路径}` 存入字典。
  4. 输出所有重复的文件组。
- **预期成果**:
  - 一个实用的Python脚本，可以快速找到文件夹中的重复文件。
  - (进阶) 为脚本添加命令行参数，如指定目录、是否真的执行删除等。
  - 理解哈希思想在实际工程（如数据去重、文件校验、版本控制系统Git）中的广泛应用。 