 
# 顺序表与链表学习蓝图

## 一、核心知识点 (Core Concepts)

这是数据结构中最基础、最核心的两种线性结构。理解它们的差异是后续学习所有其他数据结构的基础。

---

### 1. 顺序表 (Sequential List)
- **定义**: 顺序表是将元素顺序地存放在一块**连续的内存空间**里，元素间的逻辑关系和物理存储关系是一致的。
- **典型实现**: 数组 (Array)。在Python中，`list` 和 `tuple` 的底层都是基于顺序表实现的。
- **优点**:
  - **随机访问效率高**: 支持按下标随机访问，时间复杂度为 `O(1)`。因为地址可以通过 `基地址 + 索引 * 元素大小` 直接计算得出。
  - **内存空间利用率高**: 不需要额外的空间来存储元素间的关系。
- **缺点**:
  - **插入和删除效率低**: 在中间插入或删除元素，需要移动大量后续元素以保持连续性，平均时间复杂度为 `O(n)`。
  - **空间大小固定**: 创建时通常需要预先分配固定大小的空间。如果空间不足，需要进行动态扩容，这涉及开辟新空间和数据迁移，成本较高。

---

### 2. 链表 (Linked List)
- **定义**: 链表中的元素在内存中是**不连续、零散存放**的。每个元素节点除了存储数据本身 (`data`)，还必须存储一个指向下一个节点的引用 (`next`)。
- **典型实现**:
  - **单向链表 (Singly Linked List)**: 每个节点只有一个 `next` 指针，指向后继节点。
  - **双向链表 (Doubly Linked List)**: 每个节点有两个指针，`next` 指向后继，`prev` 指向前驱。
  - **循环链表 (Circular Linked List)**: 尾节点的 `next` 指针指向头节点，形成一个环。
- **优点**:
  - **插入和删除效率高**: 只需要修改目标位置前后节点的指针即可，平均时间复杂度为 `O(1)` (前提是已持有目标位置前驱节点的引用)。
  - **空间大小灵活**: 可以按需动态申请和释放内存空间，无需预先分配。
- **缺点**:
  - **随机访问效率低**: 不支持按下标随机访问。要查找第 `i` 个元素，必须从头节点开始遍历 `i-1` 次，时间复杂度为 `O(n)`。
  - **内存空间利用率较低**: 每个节点都需要额外的空间来存储指针。

### 3. 对比总结

| 特性     | 顺序表 (Array/List) | 链表 (Linked List)                     |
| :------- | :------------------ | :------------------------------------- |
| 访问方式 | **随机访问 O(1)**   | 顺序访问 O(n)                          |
| 插入/删除| **O(n)**            | **O(1)** (若有前驱节点) / O(n) (若需查找) |
| 内存空间 | 连续                | 离散                                   |
| 空间大小 | 静态/需扩容         | 动态/灵活                              |

## 二、实践项目蓝图 (Practical Project Blueprint)

### 项目1: 从零实现单向链表
- **目标**: 不使用任何内置库，手动实现一个功能完整的单向链表类。
- **功能要求**:
  1.  **节点类 `Node`**: 包含 `data` 和 `next` 两个属性。
  2.  **链表类 `SinglyLinkedList`**:
      - `__init__`: 初始化，包含一个 `head` 属性，初始为 `None`。
      - `is_empty()`: 检查链表是否为空。
      - `append(item)`: 在链表尾部添加元素。 (需要遍历到末尾)
      - `prepend(item)`: 在链表头部添加元素。
      - `insert(index, item)`: 在指定索引处插入元素。
      - `remove(item)`: 删除第一个值为 `item` 的节点。
      - `search(item)`: 查找一个元素是否存在。
      - `get(index)`: 获取指定索引处的元素值。
      - `size()`: 返回链表的长度。
      - `__str__` / `__repr__`: 实现打印链表的功能，方便调试。
- **预期成果**:
  - 一个健壮的 `SinglyLinkedList.py` 文件。
  - 编写一个 `test.py` 文件，创建链表实例并调用所有方法，以验证其正确性。

### 项目2: 实现LRU缓存淘汰算法
- **目标**: 使用**双向链表 + 哈希表**来实现一个LRU (Least Recently Used, 最近最少使用) 缓存。
- **背景**: LRU是一种常见的缓存淘汰策略。当缓存已满，需要移除一个数据时，它会移除“最近最少被访问”的那个数据。
- **算法思路**:
  1.  **使用哈希表 (字典)**: `hash_map` 用于实现 `O(1)` 的数据查找。`key` 是数据的键，`value` 是指向链表中对应节点的**引用**。
  2.  **使用双向链表**: `doubly_linked_list` 用于维护数据的“新旧”顺序。
     - 链表头部代表**最近使用**的数据。
     - 链表尾部代表**最久未使用**的数据。
  3.  **操作流程**:
     - **`get(key)`**:
       - 如果 `key` 在 `hash_map` 中，通过引用找到链表节点。
       - 将该节点移动到链表头部 (表示最近被使用了)。
       - 返回节点的值。
     - **`put(key, value)`**:
       - 如果 `key` 已存在，更新其值，并将其节点移动到链表头部。
       - 如果 `key` 不存在：
         - 如果缓存已满，删除链表**尾部**的节点，并从 `hash_map` 中也删除对应的 `key`。
         - 创建新节点，存入 `(key, value)`，将节点插入链表**头部**。
         - 在 `hash_map` 中存入 `key` 和新节点的引用。
- **预期成果**:
  - 一个 `LRUCache` 类，包含 `get` 和 `put` 方法。
  - 深刻理解哈希表和链表组合使用的威力，解决“既要O(1)查找，又要O(1)增删排序”的问题。这是面试中的高频考点。
