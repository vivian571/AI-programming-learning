# 栈 (Stack) 学习蓝图

## 一、核心知识点 (Core Concepts)

### 1. 什么是栈？
- **定义**: 栈是一种特殊的线性表，它只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为**栈顶 (top)**，另一端称为**栈底 (bottom)**。
- **核心特性**: **LIFO (Last-In, First-Out)**，即"后进先出"。最后进入栈的元素最先被移出。
- **类比**: 想象一摞盘子，你总是把新盘子放在最上面，取盘子时也总是从最上面拿。

### 2. 栈的基本操作
- **`push(item)`**: 入栈/压栈。将一个元素放到栈顶。
- **`pop()`**: 出栈/弹栈。从栈顶移除一个元素，并返回该元素。
- **`peek()`** 或 **`top()`**: 查看栈顶元素，但不移除它。
- **`is_empty()`**: 检查栈是否为空。
- **`size()`**: 获取栈中元素的个数。

### 3. 栈的实现方式
- **基于列表 (List) 实现**:
  - **优点**: 实现简单，直接使用Python的 `list` 即可。
  - **缺点**: `list` 是动态数组，当元素过多时可能触发扩容，导致 `push` 操作的摊还复杂度为 `O(1)`，但在最坏情况下（触发扩容时）会是 `O(n)`。对于非常大的栈或性能敏感的应用，这可能成为一个问题。
  - **实现**:
    - `push` -> `list.append()`
    - `pop` -> `list.pop()`
    - `peek` -> `list[-1]`
    - `is_empty` -> `len(list) == 0`
- **基于 `collections.deque` 实现**:
  - **优点**: `deque` (双端队列) 是基于双向链表实现的，两端添加和删除都是 `O(1)` 的原子操作，性能更稳定。
  - **推荐**: 在Python中，`collections.deque` 是实现栈的更佳选择。
- **基于链表 (Linked List) 实现**:
  - **优点**: 可以更好地理解栈的内部工作原理。每次 `push` 和 `pop` 都是 `O(1)`。
  - **实现**: `push` 对应在链表头部添加节点，`pop` 对应在链表头部删除节点。

## 二、实践项目蓝图 (Practical Project Blueprint)

### 项目1: 括号匹配检查器
- **目标**: 编写一个函数，检查一个包含括号的字符串 (`()`, `[]`, `{}`) 是否是有效的。
- **有效条件**:
  1. 左括号必须用相同类型的右括号闭合。
  2. 左括号必须以正确的顺序闭合。
- **算法思路**:
  1. 遍历字符串。
  2. 遇到一个**左括号**，就将其**压入栈**中。
  3. 遇到一个**右括号**，检查栈：
     - 如果栈为空，说明没有对应的左括号，无效。
     - 如果栈不为空，**弹出栈顶**的左括号，检查它是否与当前的右括号匹配。
       - 如果不匹配，无效。
  4. 遍历结束后，检查栈：
     - 如果栈为空，说明所有括号都已成功匹配，有效。
     - 如果栈不为空，说明有未闭合的左括号，无效。
- **预期成果**:
  - 一个Python函数 `is_valid_parentheses(s)`，它接受一个字符串，返回 `True` 或 `False`。
  - 几个测试用例，例如 `"{[]()}"` (True), `"{[)]}"` (False), `"{[}"` (False)。

### 项目2: 逆波兰表达式 (RPN) 计算器
- **目标**: 实现一个计算器，它可以计算逆波兰表达式（也称为后缀表达式）的值。
- **背景**: 普通的表达式是中缀表达式（如 `(1 + 2) * 3`），而后缀表达式是 `1 2 + 3 *`。它不需要括号，运算顺序是明确的。
- **算法思路**:
  1. 从左到右遍历后缀表达式字符串（以空格分隔）。
  2. 遇到一个**数字**，就将其**压入栈**中。
  3. 遇到一个**运算符**（如 `+`, `-`, `*`, `/`），就从栈中**弹出两个数字**（注意顺序：先弹出的是右操作数，后弹出的是左操作数）。
  4. 用该运算符对这两个数字进行计算，并将**结果压回栈**中。
  5. 遍历结束后，栈中应该只剩下一个数字，这个数字就是表达式的最终结果。
- **预期成果**:
  - 一个Python函数 `eval_rpn(tokens)`，它接受一个代表RPN表达式的列表（例如 `["2", "1", "+", "3", "*"]`），返回计算结果 `9`。
  - 支持 `+`, `-`, `*`, `/` 四种基本运算。
  - (进阶) 支持浮点数和负数。

### 项目3: 模拟函数调用栈
- **目标**: 通过使用栈来手动模拟一个简单的递归函数（例如计算阶乘），以加深对函数调用栈工作原理的理解。
- **算法思路**:
  1. 要计算 `factorial(n)`，传统的递归是 `return n * factorial(n-1)`。
  2. 我们可以用一个栈来模拟这个过程。栈中存放需要计算的数字。
  3. 初始时，将 `n, n-1, ..., 1` 全部压入栈。
  4. 然后，循环地从栈中弹出数字，并将它们累乘起来，直到栈为空。
- **预期成果**:
  - 一个非递归的 `factorial_stack(n)` 函数，其内部使用一个栈来完成计算。
  - 比较 `factorial_stack(n)` 和递归版本 `factorial_recursive(n)` 的结果，确保它们是一致的。
  - 一份笔记，说明函数调用是如何通过系统栈来实现的，以及你的模拟如何对应这个过程。 